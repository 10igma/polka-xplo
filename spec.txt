Specification for a Modular, Metadata-Driven Polkadot Explorer Architecture
1. Executive Summary and Strategic Alignment
This document articulates the comprehensive technical specification for a proprietary, high-performance blockchain explorer tailored to the Polkadot ecosystem. The overarching objective is to engineer a stable, extensible, and self-hosted platform that provides deep introspection into blockchain data—specifically transactions, accounts, and balances—while maintaining a minimalist user interface. Unlike monolithic legacy solutions, this architecture prioritizes modularity through a "plugin-first" design, enabling the rapid integration of new Substrate FRAME pallets and events as distinct extensions without compromising the stability of the core framework.
The proposed system leverages the Polkadot-API (PAPI) as its foundational interaction layer. This decision represents a strategic shift from the legacy polkadot-js/api library to a modern, type-safe, and light-client-optimized environment. By utilizing PAPI’s advanced metadata descriptors and "light-client first" philosophy—adapted here for full-node backend indexing—the explorer ensures forward compatibility with Polkadot’s rapid runtime evolution, including seamless handling of forkless upgrades and dynamic pallet additions.1
The architecture is defined by three critical pillars:
1. Metadata-Driven Core: The system dynamically adapts its database schema and UI components based on the on-chain metadata retrieved via PAPI, rather than relying on hardcoded logic.
2. Hybrid Indexing Engine: A robust backend that combines the reliability of a Full Node connection for historical archival with the agility of PAPI’s reactive observables for real-time data streaming.
3. Extensible Plugin System: A standardized interface for "Pallet Extensions" that encapsulates backend indexing logic and frontend UI components, effectively allowing the explorer to grow alongside the chain it monitors.3
This specification serves as the blueprint for building the source code from the ground up, ensuring ownership, stability, and adherence to the "state of the art" in 2025/2026 blockchain development.
________________
2. Technical Foundation: The Polkadot-API (PAPI) Advantage
The selection of the underlying library for blockchain interaction is the single most critical architectural decision. For years, the Polkadot ecosystem relied on polkadot-js/api. However, as the ecosystem has matured, the limitations of this legacy library—specifically regarding bundle size, memory usage, and loose typing—have become apparent. This project will exclusively utilize Polkadot-API (PAPI), the successor designed to address these specific challenges.5
2.1 The Paradigm Shift: Typed APIs and Descriptors
Legacy explorers often suffer from runtime errors when chain logic changes (e.g., a field is renamed in an event). PAPI eliminates this class of errors through its descriptor system.
* Mechanism: PAPI does not assume the shape of the chain data. Instead, it downloads the chain's metadata (a binary description of all pallets, storage items, and calls) and generates a static TypeScript definition—a "descriptor"—that maps exactly to that specific chain runtime.2
* Implication for Explorer: This allows the explorer to be "strongly typed" against the actual chain it is indexing. When the explorer code compiles, we have a guarantee that the storage queries and event listeners match the chain's capabilities.
* Multi-Chain Capability: PAPI supports multi-descriptor generation, allowing a single explorer instance to hold type definitions for Polkadot, Kusama, and a parachain simultaneously. This is a hard requirement for the "parachain support" goal, ensuring that the explorer can context-switch between networks without restarting or crashing due to type mismatches.1
2.2 Light-Client First vs. Full Node Requirements
The user specification explicitly requests the ability to "pick on a full node to gather data" while using PAPI, which is "light-client first." This presents a unique architectural duality that must be resolved.
* The Conflict: Light clients (smoldot) are excellent for end-user UIs because they verify data trustlessly without a central RPC. However, they are ill-suited for deep historical indexing (e.g., "scan all transfers from block 0") because they are designed to sync the tip of the chain, not the archive.
* The Solution: The architecture will utilize PAPI’s WebSocket Provider (WsProvider) for the backend indexer. This provider allows PAPI to connect to a traditional Archive Node via RPC, enabling the rapid retrieval of millions of historical blocks.8 Simultaneously, the frontend UI will be configured to optionally use smoldot for live data subscriptions, providing the user with cryptographic proof of their current balance while the backend handles the heavy lifting of history.9
2.3 Handling Runtime Upgrades
A "very stable framework" must survive chain upgrades. Polkadot chains upgrade their runtime logic without hard forks.
* Legacy Failure Mode: Old explorers would crash if the runtime version changed and they attempted to decode new data with old logic.
* PAPI Resilience: PAPI includes a hasNewRuntime boolean flag in every block header it processes. The specification requires the indexer to monitor this flag. Upon detection, the system must pause ingestion, fetch the new metadata version, update its internal descriptors (dynamically or via pre-compiled paths), and then resume. This ensures continuous operation through "Forkless Upgrades".2
________________
3. Core Backend Specification: The Indexing Engine
The Indexer is the engine room of the explorer. Its primary responsibility is to ingest raw block data, normalize it into a queryable format, and persist it to the database. The architecture moves away from monolithic scripts toward a modular, event-sourced pipeline.
3.1 Connection and Data Ingestion Strategy
The ingestion layer is built upon PAPI’s reactive Observable pattern. Unlike traditional polling loops (setInterval), PAPI streams data, which reduces latency and allows for "Real-Time" responsiveness.
3.1.1 The Dual-Stream Architecture
To meet the requirement of exhaustive searchability (history) and tracking (live state), the indexer must run two parallel data pipelines:
1. The Live Stream (Best Head):
   * Source: client.getBestBlock() or bestBlock$ observable.
   * Purpose: Immediate user feedback. When a user sends a transaction, they want to see it "pending" or "included" instantly.
   * Handling Reorgs: This stream is "optimistic." Data indexed from this stream must be marked as status: 'unfinalized' in the database. If the chain reorganizes (a short fork), this data may need to be overwritten. PAPI handles the detection of the best block automatically, but the database logic must be resilient to overwrites.1
2. The Canonical Stream (Finalized Head):
   * Source: client.getFinalizedBlock() or finalizedBlock$ observable.
   * Purpose: The source of truth. Data indexed here is marked status: 'finalized' and is considered immutable.
   * Gap Filling: The canonical stream also drives the "Backfill" process. If the indexer starts and detects the last finalized block in the DB is #1,000,000, but the node reports #1,000,100, it triggers a sequential fetch for the missing 100 blocks.12
3.1.2 Block Processing Logic
For every block ingested, the system performs a "Deep Extraction" routine. This is where PAPI’s TypedApi shines.
* Header Parsing: Extract standard fields: Block Number, Hash, Parent Hash, State Root, Extrinsics Root.
* Extrinsics Decoding:
   * Iterate through block.extrinsics.
   * Use PAPI to decode the opaque byte stream into a structured object: { pallet: "Balances", call: "transfer", args: { dest: "...", value: 100 } }.
   * Signer Extraction: Identify the origin. PAPI provides utilities to extract the MultiAddress signer.
   * Fee Calculation: Unlike Ethereum, fee calculation in Substrate is complex (base fee + byte fee + weight fee). The indexer must query the TransactionPayment API for the block to record the exact fee paid.1
* Event Correlation:
   * Events are the definitive record of what happened. An extrinsic might fail, but it still exists in the block. The events tell us if it succeeded (System.ExtrinsicSuccess vs System.ExtrinsicFailed).
   * Mapping: The indexer must map the list of events to the list of extrinsics using the ApplyExtrinsic phase index provided by PAPI. This allows the UI to show "This transaction failed with error: 'InsufficientBalance'".12
3.2 Database Schema Architecture
To satisfy the requirement for stability and complex searching, we employ a Hybrid Database Model. While some "light" explorers use indexedDB or strictly NoSQL, a production-grade explorer requires Relational Integrity for accounts and balances, and High-Velocity logging for events.
3.2.1 Primary Store: PostgreSQL
PostgreSQL is selected for its reliability, JSON support, and rich ecosystem.
Core Tables:
Table Name
	Description
	Key Columns
	blocks
	The chain skeleton.
	height (PK), hash (Index), parent_hash, timestamp, validator_id.
	extrinsics
	User interactions.
	id (PK), block_height (FK), tx_hash (Index), signer (Index), module, call, args (JSONB), success.
	events
	The outcome logs.
	id (PK), block_height, extrinsic_id (FK), module, event, data (JSONB).
	accounts
	Identity and state.
	address (PK), identity (JSONB), last_active_block.
	The JSONB Strategy for Extensibility:
The prompt asks to "add new pallets... as an extension."
* Problem: In a strict SQL schema, adding a new pallet with unique data would require a DB migration to add columns (e.g., staking_reward).
* Solution: We utilize Postgres JSONB columns for the args (arguments) of extrinsics and data of events.
* Benefit: When a new "Staking" extension is added, the indexer simply dumps the staking data into the JSONB column. No schema migration is needed. The specific "Staking Plugin" can then query this JSON data using Postgres's powerful JSON operators (data->>'amount').15
3.2.2 Analytics Store: ClickHouse (Optional but Recommended)
For "exhaustive" detail on large chains (like Polkadot Mainnet with millions of blocks), Postgres can slow down on aggregation queries (e.g., "Show me daily transfer volume for the last year").
* Recommendation: The architecture includes an interface for an OLAP (Online Analytical Processing) store.
* Implementation: A separate "Loader" service pipes finalized events into ClickHouse.
* Why ClickHouse? It is column-oriented, making queries like "Count all Balances.Transfer events" instant, satisfying the "track things" requirement efficiently at scale.16
________________
4. Extensibility Specification: The "Plugin" System
This section addresses the core differentiator of this project: "it would be cool if we could add new pallets and their events to it as an extension." This requirement dictates a departure from standard MVC architectures toward a Micro-Kernel or Plugin-Based architecture.
4.1 The Extension Manifest
An "Extension" is defined as a self-contained directory that encapsulates all logic required to support a specific Pallet. This ensures that the core explorer code remains "stable" and untouched when adding features.
Directory Structure:
/extensions
/pallet-staking
├── manifest.json # Definition: Name, Dependencies, Pallet ID
├── indexer/ # Backend Logic
│ ├── event-handlers.ts
│ └── migrations.sql # Optional: Custom tables for this pallet
└── ui/ # Frontend Logic
├── components/ # React components
└── hooks/ # Custom PAPI hooks
4.2 Backend Extension Architecture
The Indexer Core must implement a Plugin Registry.
* Discovery: On startup, the Indexer scans the /extensions folder and reads manifest.json files.
* Hook System: The Core Indexer exposes lifecycle hooks: onBlock, onExtrinsic, onEvent.
* Logic:
   1. Core Indexer encounters event Staking.Reward.
   2. It checks the Registry: "Do I have a plugin for 'Staking'?"
   3. If yes, it invokes the plugin's onEvent handler.
   4. The Staking Plugin: Executes custom logic—e.g., "Upsert a row into the validator_rewards table."
   5. Fallback: If no plugin is found, the Core Indexer uses the "Default Handler" which simply saves the raw event data to the events table (JSONB).
* Benefit: This guarantees that all chain data is saved (via fallback), but specific data can be processed intelligently by extensions.18
4.3 Frontend Extension Architecture
The UI faces a harder challenge: How to render a specialized component for a pallet that wasn't known at compile time?
* Dynamic Imports: We leverage Next.js's dynamic import capabilities.
* Registry Pattern: The frontend maintains a ComponentRegistry mapping Section.Method to a file path.
* Implementation Strategy:
TypeScript
// Core EventRenderer Component
const EventRenderer = ({ event }) => {
 // Dynamic import based on naming convention
 const PluginComponent = dynamic(() => 
   import(`@extensions/${event.section}/ui/${event.method}`).catch(() => null)
 );

 return (
   <Suspense fallback={<Skeleton />}>
      {/* If plugin exists, render it. Else, render Generic JSON View */}
      {PluginComponent? <PluginComponent data={event.data} /> : <JsonView data={event.data} />}
   </Suspense>
 );
}

* Result: A developer can add a Nfts folder with a Transfer.tsx component. The explorer will automatically start rendering a beautiful "NFT Card" for NFT transfers instead of raw JSON, without modifying the main EventRenderer source code.20
________________
5. Frontend User Interface Specification
The user requested a "very minimal" UI. In the context of a blockchain explorer, minimalism means high information density with low visual noise. The interface should prioritize data legibility (hashes, numbers, times) over decorative elements.
5.1 Technology Stack: Next.js + Tailwind
   * Framework: Next.js (App Router) is the industry standard. Its Server Components (RSC) are ideal for an explorer:
   * Performance: Block details (which are immutable) can be rendered entirely on the server and cached, resulting in near-instant page loads.22
   * SEO: Server-side rendering ensures search engines can index the blockchain data (useful for public explorers).
   * Styling: Tailwind CSS.
   * Constraint-Based Design: Tailwind enforces a consistent spacing and color scale, preventing the "messy" look of custom CSS.
   * Dark Mode: Built-in support is essential for developer tools.
   * Performance: Tailwind generates minimal CSS bundles, aligning with the "minimal UI" goal.9
5.2 Key Interface Modules
5.2.1 The "Omni-Search" Bar
The "Search Transactions, Accounts, and Balances" requirement demands a smart search algorithm.
   * Unified Input: A single input field on the global header.
   * Heuristic Detection:
   * Input starts with 0x & length 66: It's a Hash. Backend queries blocks and extrinsics tables simultaneously.
   * Input is numeric: It's a Block Number. Navigate to /block/[id].
   * Input matches SS58 Regex: It's an Address.
   * Validation: Use PAPI's SS58String utility to validate the checksum.
   * Normalization: Convert the specific chain format (e.g., Polkadot starts with '1') to the generic Substrate Public Key (Hex) to query the database, ensuring cross-chain compatibility.2
5.2.2 The Account & Balance Dashboard
This is a high-priority view.
   * Visual Hierarchy:
   * Top Card: The Address (with polkadot-identicon visual).
   * Balance Section: Large, clear numbers.
   * Transferable: Available for use.
   * Locked/Frozen: Staking or Democracy locks.
   * Reserved: Deposits (e.g., Identity, Proxies).
   * Live Updates: This view must not be static.
   * Implementation: Use a React Hook useLiveBalance(address) that subscribes to api.query.System.Account.watchValue(address) via PAPI.
   * Effect: As soon as a block is finalized that changes the balance, the number on the screen updates without a page refresh.12
5.2.3 The "Tracking Things" View (Assets)
To satisfy the "track things" requirement, the explorer needs a generic State Browser.
   * Concept: Beyond simple balances, Substrate chains have "Storage Maps" (e.g., Assets, Uniques, Democracy).
   * Generic Browser: A page /chain-state/[pallet]/[storage] that uses PAPI's metadata to dynamically generate a table for any storage map.
   * Metadata Inspection: PAPI knows that Assets.Asset requires an AssetId key and returns a struct with owner, supply, etc.
   * Auto-Table: The UI uses this metadata to render a table headers and rows automatically. This allows tracking "things" (Assets) without writing custom code for every new asset class.2
________________
6. Parachain and Multi-Chain Support
The specification requires the explorer to "support parachains." This implies a multi-tenant or configurable architecture.
6.1 Multi-Chain Configuration
The system will be driven by a chain-config.json file.


JSON




{
 "chains": [
   {
     "id": "polkadot",
     "name": "Polkadot",
     "rpc": ["wss://rpc.polkadot.io"],
     "color_theme": "pink",
     "address_prefix": 0
   },
   {
     "id": "assethub",
     "name": "Asset Hub",
     "rpc": ["wss://polkadot-asset-hub-rpc.polkadot.io"],
     "is_parachain": true,
     "relay_chain": "polkadot"
   }
 ]
}

6.2 PAPI Multi-Descriptor Strategy
To support multiple chains, the codebase cannot rely on a single generated type file.
   * Build Process: The build pipeline must iterate through the chain-config.json and run npx papi add <chain_name> for each entry.
   * Result: PAPI generates a distinct namespace for each chain (e.g., @polkadot-api/descriptors/dot, @polkadot-api/descriptors/assethub).
   * Context Switching: The application uses a Factory Pattern.
   * getClient(chainId): Returns the initialized PAPI client for the requested chain.
   * The frontend URL structure /chain/[chainId]/... determines which client is instantiated.
   * Insight: This allows a single deployment of the explorer to serve an entire ecosystem (Relay Chain + System Parachains) simultaneously.1
________________
7. Operational Strategy: Stability and Best Practices
To ensure the "very stable framework" requirement, the operational architecture is just as important as the code.
7.1 Docker-Based Deployment
The entire stack must be containerized to ensure consistent behavior across development and production.
   * Service Composition:
   1. explorer-db (Postgres): Persistent storage.
   2. explorer-redis: For job queues (block processing tasks).
   3. explorer-indexer: The Node.js backend service.
   4. explorer-web: The Next.js frontend.
   * Volume Management: The indexer needs significant disk I/O. Docker volumes must be mapped to high-performance SSD storage on the host.
7.2 Stability Patterns
   * Queue-Based Ingestion: Instead of processing blocks synchronously in the WebSocket loop, the "Listener" should simply push block numbers into a Redis Queue. A separate pool of "Worker" processes consumes this queue.
   * Benefit: If the database slows down, the queue buffers the blocks. The WebSocket connection doesn't drop due to backpressure. This is a critical stability pattern.3
   * Graceful Degradation: If the PAPI client disconnects, the UI should show a "Syncing..." banner but remain interactive (serving data from the DB). It should not crash or show a white screen.
7.3 Maintenance and Updates
   * Automated Metadata Updates: A cron job should run periodically to check if the chain's metadata has changed (using PAPI's getMetadata). If changed, it triggers a rebuild of the descriptors and a redeployment of the indexer. This automates the "keeping actual" requirement.
________________
8. Development Roadmap
Phase 1: The Core Skeleton (Weeks 1-4)
   * Goal: Establish the "Fundamental Base."
   * Tasks:
   * Initialize Monorepo (Turborepo).
   * Setup PAPI and generate descriptors for Polkadot.
   * Implement Basic Indexer (Blocks & Extrinsics only).
   * Setup Postgres with the core schema.
Phase 2: The Data Layer & Minimal UI (Weeks 5-8)
   * Goal: "Search transactions, accounts, and balances."
   * Tasks:
   * Implement Account Balance indexing logic.
   * Build Next.js pages: Home, Block Detail, Account Detail.
   * Implement "Omni-Search" logic.
   * Integrate Tailwind for the design system.
Phase 3: The Extension Engine (Weeks 9-12)
   * Goal: "Add new pallets... as an extension."
   * Tasks:
   * Implement the Backend Plugin Registry.
   * Build the Frontend Dynamic Import system.
   * Create the first "Reference Extension": A Staking plugin that adds a "Validators" tab to the UI and indexes rewards.
Phase 4: Parachain & Optimization (Weeks 13+)
   * Goal: "Support parachains" and "Stability."
   * Tasks:
   * Add multi-chain configuration support.
   * Dockerize the application.
   * Implement ClickHouse for event analytics (optional optimization).
________________
9. Conclusion
This specification defines a blockchain explorer that is not just a viewer, but a platform. By decoupling the core indexing logic from the specific business logic of pallets, and by leveraging Polkadot-API (PAPI) for type-safe, metadata-driven interactions, this architecture solves the twin problems of stability and extensibility. It satisfies the user's need for a "minimal" yet "exhaustive" tool that can be owned, hosted, and grown internally, representing the state-of-the-art in Polkadot infrastructure for 2026.
Detailed Research Report: Architecture & Implementation
1. Introduction: The Need for a Modern Polkadot Explorer
The Polkadot ecosystem is unique in its architectural complexity. Unlike Ethereum's singular state machine, Polkadot is a heterogeneous multi-chain environment where the "Relay Chain" secures dozens of specialized "Parachains." Furthermore, the underlying framework, Substrate, allows these chains to evolve over time without hard forks. A blockchain explorer for this ecosystem cannot simply be a clone of Etherscan; it must be fundamentally designed to handle Runtime Upgrades, Custom Pallets, and Cross-Chain Messaging (XCM).
1.1 The Legacy Problem
For years, the "reference" implementation for interacting with Polkadot was polkadot-js/api. While powerful, it grew monolithic and heavy. Explorers built on it often suffered from:
   * Brittleness: A runtime upgrade (e.g., renaming a variable in the Staking pallet) would frequently break the explorer until a developer manually updated the code.
   * Performance: The library's size and memory footprint made it difficult to run light, fast interfaces.
   * Loose Typing: Developers often had to guess the shape of data, leading to runtime crashes.
1.2 The PAPI Solution (State of the Art)
The specification demands the use of Polkadot-API (PAPI). PAPI represents a ground-up rewrite focused on:
   1. Metadata-First: It treats the chain's metadata as the "source of truth."
   2. Light-Client First: It is optimized for smoldot, enabling decentralized access.
   3. Modular Descriptors: It generates types specific to the chain connection.1
This report outlines how to build a Custom Explorer that leverages these PAPI advantages to create a system that is "Actual" (current) and "Stable."
________________
2. Core Backend Architecture: The Indexer
The backend is the most complex component. It must bridge the gap between the raw, streaming nature of the blockchain and the structured, queryable nature required by a UI.
2.1 Node Connection Strategy
The user specified: "it also should be able to pick on a full node, to gather data."
While PAPI defaults to smoldot (a light client), a light client cannot efficiently serve queries like "Get me the block from 3 years ago." It is designed to verify the current state. Therefore, our backend must connect to a Full Node (or Archive Node) via WebSocket.
Implementation Detail: PAPI WebSocket Provider
We use PAPI's WsProvider to establish a persistent connection.


TypeScript




// Architecture Snippet: Backend Connection
import { createClient } from "polkadot-api";
import { getWsProvider } from "polkadot-api/ws-provider/node"; // Note: Node.js provider

const provider = getWsProvider(process.env.ARCHIVE_NODE_URL);
const client = createClient(provider);

Insight: We must configure the provider with auto-reconnect logic. While PAPI handles the socket level, the application logic must handle "state reconciliation"—i.e., figuring out what happened while the connection was down.8
2.2 The Ingestion Pipeline Design
The indexer is not a simple script; it is a State Machine.
2.2.1 The Sync Loop
The system must maintain a pointer to the last_indexed_block. On startup:
   1. Check DB: SELECT MAX(height) FROM blocks WHERE status = 'finalized'.
   2. Check Chain: Query client.getFinalizedBlock() to find the current chain tip.
   3. Catch-Up Mode: If ChainTip > DB_Height, spawn a "Worker" to fetch blocks in batches (e.g., 100 at a time).
   4. Live Mode: Once caught up, subscribe to the finalizedBlock$ observable to process blocks as they arrive (every 6 seconds on Polkadot).
2.2.2 Handling Forks (Reorgs)
While finalized blocks never revert, the UI might want to show "Best" blocks (the bleeding edge).
   * Strategy: We store blocks with a status column.
   * status = 'best': The block is valid but could disappear.
   * status = 'finalized': The block is permanent.
   * Reorg Logic: If the indexer receives a "Best" block whose parent hash does not match the latest block in the DB, it detects a fork. It must delete the "Best" blocks from the DB that are on the abandoned fork and insert the new ones. PAPI's bestBlock$ observable handles the complexity of tracking the canonical chain, simplifying this logic for the developer.1
2.3 Data Normalization (The "Exhaustive" Requirement)
To be "exhaustive," we cannot just store raw hex. We must decode everything.
Table 1: Key Data Entities & PAPI Decoding


Entity
	PAPI Source
	Normalization Strategy
	Extrinsic
	block.extrinsics[i]
	Decode using getTypedApi. Extract section (Pallet), method (Call), and args. Crucial: Store args as JSONB to allow searching arbitrary parameters later.
	Events
	block.events[i]
	Events are grouped by phase. We must flatten this list. Map each event to its triggering Extrinsic ID. Store data payload as JSONB.
	Fees
	TransactionPaymentApi
	Substrate does not store fees in the extrinsic. We must query the Runtime API queryInfo for the extrinsic to get the inclusion fee, then check the Balances.Withdraw event for the actual fee paid (including tips).13
	Logs
	block.header.digest
	Contains Consensus info (BABE slot, Pre-runtime upgrades). Must be decoded to show "Block Producer" info in the UI.
	________________
3. The Extension System: Achieving Modularity
The requirement to "add new pallets... as an extension" is the core architectural driver. A monolithic app would require editing the Importer.ts file every time a new pallet is added. We propose a Plugin Architecture.
3.1 The "Manifest" Design Pattern
Each extension is a folder in src/extensions/.
   * Manifest: A JSON file defining the plugin.
JSON
{
 "id": "pallet-staking",
 "name": "Staking",
 "supportedEvents":,
 "supportedCalls":
}

3.2 Backend Hooks (The Indexer Plugin)
The Indexer Core emits events. Plugins subscribe to them.
      * Interface:
TypeScript
type EventHandler = (ctx: BlockContext, event: PapiEvent) => Promise<void>;

      * Example Implementation (Staking Plugin):
When the Core encounters Staking.Reward:
         1. It checks the Registry.
         2. Finds StakingPlugin.
         3. Calls StakingPlugin.onReward(ctx, event).
         4. The Plugin Logic: "Extract validator and amount from event data. Update total_staked in the staking_stats table."
         * Note: This requires the plugin to have its own database migrations (e.g., creating staking_stats). The framework must support running migrations.sql from extension folders.18
3.3 Frontend Registry (The UI Plugin)
The UI uses a Dynamic Component Registry.
         * Problem: React usually bundles everything. We don't want the "Governance" UI code if we are only browsing a "DeFi" chain.
         * Solution: Next.js Dynamic Imports with React.lazy.
TypeScript
// extensions/registry.ts
export const ExtrinsicViewers = {
 "Staking.bond": dynamic(() => import('./staking/BondViewer')),
 "Balances.transfer": dynamic(() => import('./balances/TransferViewer')),
};

         * Runtime Resolution:
When the User visits /extrinsic/[hash]:
            1. Fetch extrinsic data: { section: "Staking", method: "bond", args: {...} }.
            2. Lookup key "Staking.bond" in Registry.
            3. If found, render <BondViewer args={args} />.
            4. If not found, render <DefaultJsonViewer args={args} />.
            * Benefit: This satisfies the "Minimal" UI goal by default (clean JSON view) while allowing "Rich" views where needed.21
________________
4. Database Architecture: Hybrid Storage
To support "exhaustive" detail and "searching," a single database type is often insufficient.
4.1 The Primary Store: PostgreSQL
Postgres is the "Stable Framework" choice.
            * Why: ACID compliance is mandatory for Account Balances. We cannot tolerate "eventual consistency" when telling a user how much money they have.
            * Feature Use:
            * Partitioning: The events table will grow to billions of rows. We must partition it by block_height (e.g., one partition per month) to keep query performance high.15
            * JSONB Indexes: We create GIN indexes on the args column of extrinsics. This allows searching for "All transactions where args->>'dest' = 'Alice'"—a powerful feature for the "search" requirement.15
4.2 The Analytics Store: ClickHouse (Advanced)
For the requirement of "tracking things" (analytics), ClickHouse is the industry standard for blockchain data.
            * Use Case: "Show me the total volume of USDT transferred yesterday."
            * In Postgres: Slow SUM() over millions of rows.
            * In ClickHouse: Millisecond response due to columnar storage.
            * Integration: The Indexer (Node.js) writes to Postgres for safety, and a background process (or the same indexer) batches events into ClickHouse for analytics.
            * Note for Specification: Start with Postgres. Add ClickHouse only if the chain volume exceeds ~10M blocks/year.16
________________
5. Frontend User Interface: Minimal & Fast
The UI must not distract from the data.
5.1 Technology: Next.js App Router
We use the App Router (app/) architecture.
            * Server Components (RSC): Pages like /block/[id] are static once finalized. We render them on the server. This means the browser receives ready-made HTML, ensuring the "minimal" feel involves minimal loading spinners.22
            * Streaming: For data that takes longer (e.g., fetching checking extension plugins), we use React Suspense boundaries to stream the UI in chunks.
5.2 The "Tracking Things" Dashboard
The user wants to "track things." In Polkadot, "things" are often assets on the Assets or Uniques (NFT) pallets.
            * Generic State Browser:
            * PAPI exposes api.query.[Pallet]..getEntries().
            * We can build a generic page: /state/[pallet]/[storage].
            * Example: User visits /state/Assets/Asset. The explorer fetches all entries. PAPI decodes the keys (Asset IDs) and values (Supply, Owner). The UI renders a table.
            * Innovation: This allows "tracking things" without writing any custom code. The explorer discovers the "things" via metadata.2
5.3 Live Balance Tracking
The "Account" page must feel alive.
            * Static vs. Dynamic:
            * Header: "Balance at Block #100" (Static, from DB).
            * Overlay: "Current Balance" (Dynamic, from Node).
            * Implementation:
We create a custom hook usePapiBalance(address).
TypeScript
const usePapiBalance = (address) => {
 const = useState(null);
 useEffect(() => {
   const sub = client.getTypedApi(dot).query.System.Account.watchValue(address)
    .subscribe(val => setBalance(val.data));
   return () => sub.unsubscribe();
 }, [address]);
 return balance;
}

This satisfies the requirement to "remain actual" on current development using PAPI's observables.12
________________
6. Parachain Support and Configuration
The explorer must be capable of being "the explorer of a parachain."
6.1 Multi-Tenancy Configuration
The system is configured via explorer.config.js.


JavaScript




export default {
 chains: {
   polkadot: {
     ws: ["wss://rpc.polkadot.io"],
     theme: { primary: "#E6007A" },
     descriptor: "dot" // Maps to PAPI generated descriptor
   },
   moonbeam: {
     ws: ["wss://wss.api.moonbeam.network"],
     theme: { primary: "#53CBC9" },
     addressType: "H160", // Ethereum-style address support
     descriptor: "mrt"
   }
 }
}

6.2 Address Formatting
Parachains like Moonbeam use Ethereum (H160) addresses. Polkadot uses SS58.
               * PAPI Support: PAPI handles both MultiAddress types.
               * UI Logic: The frontend must detect the chain configuration. If addressType === 'H160', it bypasses the SS58 encoding logic and displays the raw 0x string. This ensures the explorer works for EVM-compatible parachains as well.2
________________
7. Operational Best Practices: Stability
To ensure the "very stable framework" requirement:
7.1 The Queue Pattern
Indexing allows no downtime. If the Node.js process crashes, we miss blocks.
               * Redis Queue: The "Listener" process does nothing but push Block Numbers into Redis. It is extremely lightweight and rarely crashes.
               * Worker Pool: Heavy "Processors" pull numbers from Redis. If a Processor crashes on a weird transaction, the job remains in Redis and is retried. This isolates faults.3
7.2 Health Checks
The API must expose /health.
               * Checks:
               1. Node Connectivity: Is PAPI connected?
               2. Sync Lag: Is ChainTip - DbTip < 5?
               3. DB Connectivity: Can we query Postgres?
               * This allows a load balancer (like Nginx) to restart the service automatically if it hangs.
________________
8. Conclusion
This specification outlines a path to build a Proprietary, Modular, and Future-Proof Polkadot Explorer. By anchoring the technology stack on Polkadot-API (PAPI), we gain Type Safety, Light-Client readiness, and seamless Metadata adaptability—features that legacy explorers lack. The Plugin Architecture ensures that the explorer can scale with the user's needs, adding support for new pallets like "Staking" or "NFTs" without creating a maintenance nightmare. This is the blueprint for a state-of-the-art explorer in 2026.
Referenzen
               1. Polkadot-API | Polkadot Developer Docs, Zugriff am Februar 10, 2026, https://docs.polkadot.com/reference/tools/papi/
               2. Types · PAPI - Polkadot-API, Zugriff am Februar 10, 2026, https://papi.how/types/
               3. subscan-explorer/subscan-essentials: Polkadot Substrate Explorer Subscan - GitHub, Zugriff am Februar 10, 2026, https://github.com/subscan-explorer/subscan-essentials
               4. opensquare-network/statescan-v2: Explorer for substrate chains - GitHub, Zugriff am Februar 10, 2026, https://github.com/opensquare-network/statescan-v2
               5. Unlocking Polkadot with PAPI ⚡️ the Polkadot API - Space Monkeys 177 - YouTube, Zugriff am Februar 10, 2026, https://www.youtube.com/watch?v=W9bDGl-d-qQ
               6. Polkadot.js API | Polkadot Developer Docs, Zugriff am Februar 10, 2026, https://docs.polkadot.com/reference/tools/polkadot-js-api/
               7. Connect to multiple chains · PAPI - Polkadot-API, Zugriff am Februar 10, 2026, https://papi.how/recipes/connect-to-multiple-chains/
               8. WS Provider - Polkadot-API, Zugriff am Februar 10, 2026, https://papi.how/providers/ws/
               9. Building a Polkadot Wallet Dashboard with PAPI (Polkadot API) | by Kanas - Medium, Zugriff am Februar 10, 2026, https://medium.com/@nasihudeen04/building-a-polkadot-wallet-dashboard-with-papi-polkadot-api-381ee5a79d5c
               10. PAPI and Runtime Upgrades: Making DApps Truly Resilient - Tech Talk - Polkadot Forum, Zugriff am Februar 10, 2026, https://forum.polkadot.network/t/papi-and-runtime-upgrades-making-dapps-truly-resilient/13178
               11. polkadot-api/packages/client/src/types.ts at main - GitHub, Zugriff am Februar 10, 2026, https://github.com/polkadot-api/polkadot-api/blob/main/packages/client/src/types.ts
               12. Events · PAPI - Polkadot-API, Zugriff am Februar 10, 2026, https://papi.how/typed/events/
               13. Runtime API Calls | Polkadot Developer Docs, Zugriff am Februar 10, 2026, https://docs.polkadot.com/chain-interactions/query-data/runtime-api-calls/
               14. Blocks | polkadot{.js}, Zugriff am Februar 10, 2026, https://polkadot.js.org/docs/api/cookbook/blocks/
               15. On-Chain Series VIII: Scaling Transaction Indexing with PostgreSQL and Hybrid Storage Architecture - CoinDesk Data, Zugriff am Februar 10, 2026, https://data.coindesk.com/blogs/on-chain-series-viii-scaling-transaction-indexing-with-postgresql-and-hybrid-storage-architecture
               16. Comparing ClickHouse and PostgreSQL, Zugriff am Februar 10, 2026, https://clickhouse.com/docs/migrations/postgresql/overview
               17. ClickHouse and PostgreSQL, Zugriff am Februar 10, 2026, https://clickhouse.com/comparison/postgresql
               18. Plugin System Design How to Build Extensible Framework Core Architecture（1751339312483300） - DEV Community, Zugriff am Februar 10, 2026, https://dev.to/member_14fef070/plugin-system-design-how-to-build-extensible-framework-core-architecture1751339312483300-1k6e
               19. Building Extensible Go Applications with Plugins | by Thisara Weerakoon - Medium, Zugriff am Februar 10, 2026, https://medium.com/@thisara.weerakoon2001/building-extensible-go-applications-with-plugins-19a4241f3e9a
               20. Mastering Dynamic Component Loading in Next.js for High-Performance Apps - Medium, Zugriff am Februar 10, 2026, https://medium.com/@pooja.1502/mastering-dynamic-component-loading-in-next-js-for-high-performance-apps-3a6aba6f67cf
               21. Guides: Lazy Loading | Next.js, Zugriff am Februar 10, 2026, https://nextjs.org/docs/pages/guides/lazy-loading
               22. Next.js best practices in 2025: Mastering modern web development - August Infotech, Zugriff am Februar 10, 2026, https://www.augustinfotech.com/blogs/nextjs-best-practices-in-2025/
               23. Query Account Information with SDKs | Polkadot Developer Docs, Zugriff am Februar 10, 2026, https://docs.polkadot.com/chain-interactions/accounts/query-accounts/
               24. opensquare-network/statescan: Statemint asset explorer - GitHub, Zugriff am Februar 10, 2026, https://github.com/opensquare-network/statescan
               25. How to Build a Real-Time Blockchain Dashboard with PAPI - DEV Community, Zugriff am Februar 10, 2026, https://dev.to/cherrypick14/how-to-build-a-real-time-blockchain-dashboard-with-papi-44d3
               26. Introduction to Polkadot Hub - YouTube, Zugriff am Februar 10, 2026, https://www.youtube.com/watch?v=PqzUtLp2Oxc
